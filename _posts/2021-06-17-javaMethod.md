---
title: 메소드(Method) 파악하기
author: Kim
date: 2021-06-17 13:52:00 +0900
categories : [Java]
tags: [Java]
---

## 메소드

보통 다른언어에는 함수라는 것이 별도로 존재합니다 하지만 자바에서는<br>
클래스를 떠나 존재하는 것은 있 을 수 없기 때문에 자바의 함수는 따로 존재하지 않고<br>
클래스 내에 존재합니다 따라서 자바는 클래스 내의 함수를 메소드라고 부릅니다.<br>

이번 메소드에서는 입출력 위주로 메소드에 대해서 좀 더 자세히 알아 볼 필요가 있습니다<br>
메소드를 설명하기 전에 믹서기를 생각해봅시다<br>

```java
믹서기

믹서기에 과일을 넣는다 → 믹서기를 이용해서 과일을 갈아 주스를 만든다
```

보통 믹서기는 위와 같은 방법으로 작동합니다 이것을 프로그래밍 으로 생각해보면<br>

```과일을 넣는다``` 는 ```입력```이 되고 ```믹서기를 이용해서 과일을 갈아 주스를 만드는 것은```<br>
```출력```이 되는 것 처럼 볼 수 있습니다<br>

여기서 믹서기는 메소드 역할을 하는것 과 같습니다<br>
따라서 메소드는 입력을 가지고 어떤 일을<br>
수행한 다음 결과물을 내어 출력 하는 것이 메소드가 하는 일 입니다.<br>

```필요한 부분```을 ```한 뭉치``` 로 묶어 어떤 입력값이 주어지면<br>
이에 입력값에 맞는 리턴값을 돌려준다 라는 식의 메소드를<br>
작성하는 것이 효율적 일 것 입니다<br>

가장 간단하지만 많은 것을 설명해 줄수 있는 다음의 코드를 보겠습니다 <br>

```java
public int sum (int a , int b ) {
	return a + b;
}
```

위 메소드는 다음과 같은 의미로 볼 수 있습니다<br>

```sum``` 이라는 메소드는 ```입력값 a 와 b```를 받고 ```리턴 값은 a + b 의 합``` 입니다<br>
여기서 return 이라는 키워드는 sum 메소드의 결과를 돌려주는 명령어 이고<br>

위 메소드를 직접 만들어 보고 결과를 출력해보도록 하겠습니다<br>

## sum Method 실습하기.

```java
public class SumTest {
		
	public int sum (int a , int b) {
		return a + b;
	}
	public static void main(String[] args) {
		
		int a = 100;
		int b = 10;
		
		SumTest st = new SumTest();
		int result = st.sum(a, b);
		System.out.println(result);
	}
}
```
위 코드는 sum 메소드에 100 , 10 입력값을 main 에서 전달하여<br>
결과는 110 을 돌려받는 예제입니다<br>

## 메소드의 입력값과 리턴값 

메소드는 들어온 입력값을 가지고 어떤 처리를 하여 적절한 리턴값을 돌려준다<br>
라는 개념만 익히도록 하면 프로그래밍 하는데 있어서 어렵진 않을 것 입니다<br>

자바의 메소드 구조는 다음과 같습니다<br>

public 키워드를 이용하여 그 이후에 리턴자료형 + 메소드 명이 들어갑니다<br>

```java
public 자료형 메소드명 (입력자료형1 , 입력변수1 , 입력자료형2 , 입력변수2 …
return 리턴값
```

```리턴자료형```은 메소드가 수행 후 돌려줄 값의 자료형을 의미합니다<br>
메소드의 리턴값은 반드시 return 키워드를 이용하도록 하고<br>

메소드는 입출력 유무에 따라 다음과 같이 4가지로 분류할 수 있습니다<br>

* (1) : 입력과 출력이 모두 있는 메소드
* (2) : 입력과 출력이 모두 없는 메소드
* (3) : 입력은 없고 출력은 있는 메소드
* (4) : 입력은 있고 출력은 없는 메소드

### (1) 일반 메소드
※ 입력 값도 있고 리턴값이 있는 메소드가 일반 메소드 입니다 <br>
예를 한번 보도록 하면<br>

```java
public int sum (int a , int b ) {
	return a + b;
}
```

sum 메소드의 입출력 자료형은 다음과 같습니다

``` java
입력값 → int 자료형 : a , b
리턴값 → int
```

위 메소드는 두 개의 입력값을 받아서 서로 더한 결과값을 돌려주는 메소드 입니다<br>

위처럼 입력값과 리턴값이 있는 메소드는 Main에서 다음처럼 사용 할 수 있습니다<br>

```리턴값을받을 변수 = 객체명.메소드명(int a , int b ) int res = objectname.methodname```

위 말대로 한 코드는 다음과 같습니다<br>

```java
SumTest st = new SumTest();
		
int result = st.sum(a, b);
```

st.sum 호출 한 다음 리턴값을 저장하는 int result 의 자료형은 반드시 int 이어야 합니다<br>
그 이유는 sum 메소드의 리턴 자료형이 int 이기 때문입니다<br>

### (2) 입력값이 없는 메소드

입력값이 없는 메소드가 정말 존재할까요 ? 답은 그렇습니다 다음 코드를 보도록 합시다<br>

```java
public String say() {
	return “Hello ?”;
}
```
say 메소드의 입출력 자료형은 다음과 같습니다<br>

```java
입력 값 : X
리턴 값 : String 자료형
```

say 라는 이름의 메소드를 만들었지만 입력 인수부분을 나타내는 괄호 안이 비어있습니다<br>
그럼 이 메소드는 어떻게 사용 할까요 ?<br>

```java
Test test = new Test();
		
String res = test.say();
```		

say 메소드처럼 쓰기 위해서는 say() 처럼 비어있는 괄호 안에 아무런 값도 넣어주지 않고<br>
사용해야 합니다 say 메소드는 입력값은 없지만 리턴값으로 Hello ? 라는 돌려주는데<br>
따라서 String res = test.say() 처럼 하면 res 변수에는 해당 문자열이 대입 되게 하는 것이죠<br>

즉 입력값이 없고 리턴값만 있는 메소드는 아래와 같이 구현 할 수 있습니다.<br>

```리턴값변수 = 객체.메소드명() == <String res = objectname.methodname>```

### (3) 리턴값이 없는 메소드

리턴값이 없는 메소드도 역시 존재하는데 다음의 예를 보겠습니다<br>

```java
public void sum ( int a , int b ) {
	System.out.println(a + “ ” + b + “의 합은 ” + (a + b) + “입니다”);
}
```

위 메소드의 입출력 자료형은 다음과 같습니다<br>
```java
입력값 : int 자료형
리턴값 : void ( void는 없음 이라는 의미입니다 )
```
```리턴값이 없는 메소드는 명시적```으로 리턴타입 부분에 ```void``` 라고 표기해야 합니다<br>
```리턴값이 없는 메소드는``` 돌려주는 값이 없기 때문에 다음과 같이 사용 할 수 있습니다<br>

```java
Test test = new Test();
test.sum(3,4)
```

리턴값이 없는 메소드는 다음과 같이 사용합니다<br>

```객체.메소드명 (인수1 , 인수2 )```<br>

실제로 이 메소드를 호출해 본 결과 다음과 같은 문자열이 출력됩니다<br>

```3과 4의 합은 7 입니다.```<br>

하지만 3과 4의 합은 7입니다 라는 문장은 어떻게 출력 된 것 일까요 ?<br>
리턴값이 분명 없다고 했지만 ```System.out.println()``` 메소드는 단지 ```메소드내에서 사용된```<br>
문장일 뿐 돌려주는 값은 없으므로 혼동을 피해야 합니다<br>
※ 돌려주는 값은 return 키워드 만을 이용해야 합니다 , 값은 사용할 수 없습니다<br>


## return 의 또 다른 쓰임새

특별한 경우에 메소드를 빠져나가기를 원할 때 return만 단독으로 사용해서<br>
메소드를 즉시 빠져나갈 수 있습니다.<br>

```java
public void say(String s) {
	if (“fool”.equals(s) ) {
		return ; // 즉시 종료!
}
System.out.println(“Ahhhh ~~” + s)
}
```

위 메소드는 입력값으로 s 를 받아서 문자열을 출력합니다<br>
이 메소드 역시 리턴값은 없으며 단순히 say 메소드안에 있는<br>
System.out.println 메소드로 문자열을 출력하는 것 이기 때문에<br>
혼동되지 않아야 합니다<br>

이 메소드는 ```fool 이라는 값```이 들어오면 문자열을 출력하지 않고<br>
즉시 메소드를 빠져나가 종료시킵니다 이렇게 메소드 수행 시<br>
특정 조건에 따라 메소드를 즉시 빠져나가고 싶을 땐 ```return ;``` 을<br>
사용하면 됩니다<br>

※ return 키워드만 사용해서 메소드를 빠져나가는 이 방법은<br>
리턴자료형이 void 형인 메소드에만 해당됩니다<br>
리턴 자료형이 명시되어 있는 메소드에서 return 문만 작성하면<br>
컴파일 시 오류가 발생합니다<br>

## 메소드 내에서 선언된 변수의 효력 범위

``` 메소드안에서 사용하는 변수``` 의 이름을 메소드 밖에서 사용한<br>
이름과 동일하게 사용한다면 어떻게 될까요 ?<br>

아래의 예제를 보면 확실히 알 수 있습니다<br>

```java
class Test {
    public void vartest(int a) {
        a++;
    }

    public static void main(String[] args) {
        int a = 1;
        Test myTest = new Test();
        myTest.vartest(a);
        System.out.println(a);
    }
}
```

위 예제의 ```vartest 메소드```는 입력으로 들어온 int 자료형의 값을 1만큼 증가시키는<br>
역할하는 것 처럼 보일 것 입니다 이제 main 메소드의 순서대로 분석해 보면<br>

main 메소드에서 자료형 int a 의 변수를 생성한 다음 1을 대입하였습니다<br>
그리고 vartest 메소드를 입력 값 a를 주어 호출하였고 그 다음 출력하도록 하였습니다<br>
순서대로 진행해 봤을때 vartest 메소드에서 a의 값을 1만큼 증가 시켜 2가 출력되어야<br>
할 것 같지만 결과는 1이 나옵니다<br>

이렇게 된 이유는 ```메소드 내에서 사용되는 변수```는 ```메소드 안에서만 쓰여지는```<br>
변수이기 때문입니다 즉 ```public void vartest(int a)``` 문장에서 입력 인수를 뜻하는<br>
변수 a는 메소드 안에서만 쓰이는 변수이지 main 변수 가 아니라는 걸로 봐야합니다<br>

즉 메소드에서 쓰이는 변수는 메소드 밖의 변수이름이랑 전혀 상관없는 관계라고<br>
봐도 됩니다 그래서 이렇게 ```메소드 내에서만 쓰이는 변수를 로컬변수``` 라고 부르게되죠<br>

※ 만약 vartest의 입력값이 int 자료형이 아닌 객체였다면 얘기가 달라집니다<br>
```객체를 메소드의 입력```으로 넘기고 ```메소드가 객체의 속성값을 변경한다면?```<br>

메소드 수행 이후에도 객체는 변경된 속성값을 유지하며 이러한 차이가 나는 이유는<br>
메소드에 전달하는 입력 자료형의 형태 때문인데 메소드에 값을 전달하는지 아니면<br>
객체를 전달하는지에 따라 결과는 달라집니다<br>


그러면 어떻게 vartest 메소드를 이용해서 메소드 외부의 a를 1만큼 증가시킬 수 있을까요?<br>

먼저 다음과 같이 vartest 메소드와 main 메소드를 변경해보았습니다<br>

```java
public int vartest(int a) {
    a++;
    return a;
}

public static void main(String[] args) {
    int a = 1;
    Test myTest = new Test();
    a = myTest.vartest(a);
    System.out.println(a);
}
```
일단 위 예처럼 vartest메소드에 return 문을 사용하는 방법입니다 vartest 메소드는<br>
입력으로 들어온 값을 1만큼 증가시켜 리턴하는데<br>

따라서 ``` a = myTest.vartest(a)``` 처럼 하면 a의 값은 vartest 메소드의 리턴값으로<br>
대입됩니다<br>


## 객체를 넘기는 방법

```java
package CMExample;

public class Test02 {
	
	int a ; 객체변수
	
	public void sum (Test02 test) {
		test.a ++;
	}
	
	public static void main(String[] args) {
		
		Test02 test02 = new Test02();
		test02.a = 1;
		test02.sum(test02);
		System.out.println(test02.a);	
	}
}
```
이전 에서는 a 라는 int 자료형 변수를 main 메소드에 선언했는데 위 예제에는<br>
다음과 같이 ```Test02 클래스의 객체변수```로 선언하였습니다<br>

Test02 의 int a 는 객체변수 a 이고<br>
sum 메소드는 다음과 같이 Test02 클래스의 객체를 입력받아 해당 객체의 객체변수 a의<br>
값을 1만큼 증가시키는 역할을 하도록 수정하였습니다<br>

```java
public void sum(Test02 test ) {
	test.a ++;
}
```

그리고 sum 메소드는 다음과 같이 Test클래스의 객체를 입력받아 해당 객체의<br>
객체변수 a의 값을 1만큼 증가시키는 역할을 하도록 한 것이죠<br>

마지막으로 main메소드 에서는 sum 메소드에 1을 전달하던것을 Test클래스의 객체인<br>
test02를 넘기도록 수정 하였습니다<br>

이렇게 되면 결과는 2 가 될 것 입니다<br>

sum ```메소드의 입력 파라미터가 값이 아닌 객체``` 일땐<br>
```메소드가 객체를 받는 순간 메소드 내의 객체는 전달받은 객체 그 자체로 수행합니다```<br>
따라서 입력으로 전달받은 test02 객체의 객체변수 a의 값이 증가하게 됩니다<br>